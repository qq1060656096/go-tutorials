# 为什么要工程化（究竟是提高技术能力 还是 工程化能力）

```
1. 技术能力还是工程能力
2. 为什么要工程化
3. 混乱的项目问题
4. 标准统一的项目优势
5. Kit 基础库特点
```

### 1. 究竟是提高技术能力 还是 工程化能力
```go
举两个例子，你可以感受一下其中的明显差异。

一个例子是在 LeetCode 上刷题。最近行业里还挺流行干这事儿的，不停地刷题可以让你对数据结构算法更熟悉，也能更熟练地用语言去解决一些小的技术问题。

另一个例子是在项目组里写 CRUD。如果从难度的角度判断，我们都会觉得刷题对于技术的要求更高，而在项目中写 CRUD 的技术含量并不高。

没错，因为它们要求的能力完全不同。你试着回想一下，在 LeetCode 上刷题时，通常会希望自己能在限定时间内尽可能快地、一次性地把代码写完。也就是说，代码写完就完成了，很少需要在此基础上进行二次开发或反复修改。以写为主，而改为辅。

相反，在项目组做 CRUD 时，从技术上看，我们就是在做 CRUD。但与此同时，还需要理解“我为什么要做 CRUD”。这就牵扯到应该如何理解业务上下文和业务逻辑等问题。

随着业务的发展，很少会出现一次性的、代码写完就完成了的情况。因而在项目组做 CRUD 时，写代码可能仅仅占据整个代码生命周期的 5%。剩下的 95%，都是根据需求变化和功能调整，在 CRUD 的基础上再不断迭代。

可以说，从刷题中获得的技术能力，哪怕再强，一旦放到项目组中实际应用，至多能把效率提高 10 倍。假设原来是 5%，提高 10 倍就是 0.5%。即便如此，仍然有 95% 需要在代码的基础上反复修改调整。而这些能力，从刷题中是学不到的。

从而发现，在项目组中做 CRUD 其实更需要我们的工程能力，而在 LeetCode 上刷题，需要的仅仅是技术能力。

随着业务需求的变化，导致代码越来复杂，而面向对象、设计模式、设计原则都是解决项目复杂的问题，所以我们在业务开发中注重工程能力。
```

### 2. 为什么要工程化

```
我们尝试学习 Go，或者我们正在为自己建立一个简单项目（或说一个玩具项目），没什么必要工程化。一个 main.go 文件绰绰有余。
当有更多的人参与这个项目时，我们需要一些大家都遵循的标准的规范来开发项目。目的是减少项目成员之间的沟通成本和出错的可能。
```

### 3. 混乱的项目
```
1. 各种风格代码布局导致项目成员之间无法用共同熟悉的语言进行交流和描述，并且容易在沟的时候产生的误解
2. 每个项目不同代码风和格布局，导致每个项目文档都要描述这些重复的事情
3. 项目中相同的功能使用不同的库（如 orm，包管理）
    例如：
        1.我们项目 一会使用 dep 做包管理，一会使用 go mod 做包管理
        2.一会使用 sqlx，一会使用 gorm 操作数据库
4. 项目成员流动带来额外的沟通、理解和记忆成本 

为什么每个项目都要去理解记忆相同的事情，而且我们本身习惯经验式编程（就是一切都从经验出发），所谓经验式编程是指开发者往往经常不会认真的读完文档，
而是根据思维的连续性，以往的经验来预先假定功能。所以我们要遵循（保持普遍统一认知的设计 、 保持设计概念上的一致性）的标准规范来开发项目。

```

### 4. 标准统一的项目优势
```
1. 保持普遍统一认知的设计
2. 保持设计概念上的一致性
2. 语言本生是模糊的，标准统一的规范可以减少沟通产生的误解，项目成员之间可以使用共同熟悉的语言进行交流和描述
3. 清晰的命名、标准统一的代码和布局，减少项目人员去理解和记忆的成本
```

### 5. Kit 基础库特点 
> 将 Kit 项目作为公司的标准库，因此应该只有一个。并且 Kit 基础库也应该具备以下这些特点：

```
简单：不过度设计，代码平实简单；
通用：通用业务开发所需要的基础库的功能；
高效：提高业务迭代的效率；
稳定：基础库可测试性高，覆盖率高，有线上实践安全可靠；
健壮：通过良好的基础库设计，减少错用；
高性能：性能高，但不特定为了性能做 hack 优化，引入 unsafe ；
扩展性：良好的接口设计，来扩展实现，或者通过新增基础库目录来扩展功能；
容错性：为失败设计，大量引入对 SRE 的理解，鲁棒性高；
工具链：包含大量工具链，比如辅助代码生成，lint 工具等等；
```

