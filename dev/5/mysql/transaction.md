# MySQL事务

```
1.什么是事务
2.为什么要用事务
3.事务特性
  3.1.原子性(Atomicity)
  3.2.一致性(Consistency)
  3.3.隔离性(Isolation)
  3.4.持久性(Durability)
4.事务隔离级别
5.事务隔离性造成的问题
6.事务4种隔离级别
  6.1.未提交读(READ UNCOMMITED)
  6.2.提交读(READ COMMITTED)
  6.3.可重复读(REPEATABLE READ)
  6.4.可串行化(SERIALIZABLE)
```
## 1.什么是事务
```
事务是数据库管理系统执行过程中的一个逻辑单位,由一个有限的数据库操作序列构成.
通俗地讲,事务是一组原子性的 SQL 查询,事务内的操作完全执行,要么这些操作全不执行,不存在中间状态
```

## 2.为什么要用事务
```
```


## 3.事务特性

### 3.1 原子性(Atomicity)
```
事务中所有操作要么全部提交成功,要么全部失败回滚.对事务来说,不可能只执行其中的一部分
```

### 3.2 一致性(Consistency)
```
是指数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态
也就是说A、B两人在转账钱的总和是2,000，转账后两人的总和也必须是 2,000. 不会因为这次转账事务破坏这个状态.
如果帐户A上的钱减少了,而帐户B上的钱却没有增加,那么我们认为此时数据处于不一致的状态
```

### 3.3 隔离性(Isolation)
```
事务的隔离性是指一个事务的执行不能被其他事务干扰,即一个事务内部的操作及使用的数据对并发的其他事务是隔离的.
因此,每个事务都感觉不到系统中有其它事务在并发地执行,不同的事务之间彼此没有任何干扰.
比如A转出100但事务没有确认提交,这时候银行人员对其账号查询时,看到的应该还是1,000而不是900
```

### 3.4 持久性(Durability)
```
一旦事务提交,其所做的修改就会永久保存到数据库中.此时,即使系统崩溃,修改的数据也不会丢失
```

## 4.事务隔离级别
```
事务每一种隔离级别都规定了一个事务中所作的修改,哪些在事务内和事务之间是可见的,哪些是不可见的.
较低的隔离级别通常可以执行更高的并发,系统开销也更低.
```

## 5.事务隔离性造成的问题

```
1.脏读: 事务A读取了事务B更新的数据,然后B回滚操作,那么A读取到的数据是脏数据

2.不可重复读: 事务 A 多次读取同一数据,事务 B 在事务A多次读取的过程中,对数据作了更新并提交,导致事务A多次读取同一数据时,结果不一致

3.幻读: 系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级,但是系统管理员B就在这个时候插入了一条具体分数的记录,当系统管理员A改结束后发现还有一条记录没有改过来,就好像发生了幻觉一样,这就叫幻读

不可重复读的和幻读很容易混淆,不可重复读侧重于修改,幻读侧重于新增或删除.解决不可重复读的问题只需锁住满足条件的行,解决幻读需要锁表
```

## 6.事务4种隔离级别

### 6.1.未提交读(READ UNCOMMITED)
```
事务中的修改,即使没有提交,对其它事务也都是可见的.
通俗的说: 所有事务都可以看到其他未提交事务的执行结果
可能发生脏读:即事务可以读取未提交的数据.(实际中很少使用)

示例:
- 事务A和事务B，事务A未提交的数据，事务B可以读取到
- 这里读取到的数据叫做“脏数据”
- 这种隔离级别最低，这种级别一般是在理论上存在，数据库隔离级别一般都高于该级别
```

### 6.2.提交读(READ COMMITTED)
```
一个事务开始时,只能看见已经提交的事务所做的修改.这个级别有时候也叫做不可重复读,因为它不保证事务重新读的时候能读到相同的数据.
因为在每次数据读完之后其他事务可以修改刚才读到的数据.
考虑下面这种情况：A事务读取一个数据项var=1,然后B事务更新该数据var=2并提交,A事务接着又重新读了该数据,结果var=2,
第二次读到的数据和第一次的不相同.大多数数据库系统的默认隔离级别是 READ COMMITTED(但是MySQL不是)

示例:
- 事务A和事务B，事务A提交的数据，事务B才能读取到
- 这种隔离级别高于读未提交
- 换句话说，对方事务提交之后的数据，我当前事务才能读取到
- 这种级别可以避免“脏数据”
- 这种隔离级别会导致“不可重复读取”
- Oracle默认隔离级别
```


### 6.3.可重复读(REPEATABLE READ)
```
只允许读取已经提交的数据,而且在一个事务两次读取一个数据项期间,其它事务不得更新该数据.但该事务不要求和其它事务可串行化.
可能存在幻读问题：当某个事务在读取某个范围内的记录时,另外一个事务又在该范围内插入了新的记录,
当之前的事务再次读取该范围的记录时,会产生幻行.(可重复读是 MySQL 的默认事务隔离级别)

示例:
- 事务A和事务B，事务A提交之后的数据，事务B读取不到
- 事务B是可重复读取数据
- 这种隔离级别高于读已提交
- 换句话说，对方提交之后的数据，我还是读取不到
- 这种隔离级别可以避免“不可重复读取”，达到可重复读取
- 比如1点和2点读到数据是同一个
- MySQL默认级别
- 虽然可以达到可重复读取，但是会导致“幻像读”
```


### 6.4.可串行化(SERIALIZABLE)
```
最高的事务隔离级别,在该级别下,事务串行化顺序执行,可以避免脏读、不可重复读与幻读.
但是这种事务隔离级别效率低下,比较耗数据库性能(一般不使用)

示例:
- 事务A和事务B，事务A在操作数据库时，事务B只能排队等待
- 这种隔离级别很少使用，吞吐量太低，用户体验差
- 这种级别可以避免“幻像读”，每一次读取的都是数据库中真实存在数据，事务A与事务B串行，而不并发
```